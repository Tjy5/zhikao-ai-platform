#!/usr/bin/env pwsh

param(
  [int]$BackendPort,
  [int]$FrontendPort,
  [switch]$NoDB
)

# Set default values if not provided
if (-not $BackendPort) { $BackendPort = 65123 }
if (-not $FrontendPort) { $FrontendPort = 65124 }

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

Write-Host "🚀 启动全栈开发环境（稀有固定端口 + 端口复用）" -ForegroundColor Green
Write-Host ("=" * 80) -ForegroundColor Gray

function Test-PortInUse {
  param([Parameter(Mandatory = $true)][int]$PortToTest)
  try {
    $client = New-Object System.Net.Sockets.TcpClient
    $iar = $client.BeginConnect('127.0.0.1', $PortToTest, $null, $null)
    $completed = $iar.AsyncWaitHandle.WaitOne(600)
    if ($completed -and $client.Connected) { $client.Close(); return $true }
    $client.Close(); return $false
  } catch { return $false }
}

function Wait-ForPortUp {
  param([Parameter(Mandatory = $true)][int]$Port,[int]$TimeoutSec = 20)
  $elapsed = 0
  while ($elapsed -lt $TimeoutSec) {
    if (Test-PortInUse -PortToTest $Port) { return $true }
    Start-Sleep -Seconds 1
    $elapsed++
  }
  return (Test-PortInUse -PortToTest $Port)
}

function Write-PortFile {
  param([string]$Name,[int]$Port)
  $file = Join-Path $PSScriptRoot "${Name}_port.txt"
  $Port | Out-File -FilePath $file -Encoding utf8 -NoNewline
  return $file
}

function Maybe-Start-DB {
  if ($NoDB) { return }
  $composeAtRoot = Join-Path $PSScriptRoot "docker-compose.yml"
  if (Test-Path $composeAtRoot) {
    if (Get-Command docker -ErrorAction SilentlyContinue) {
      Write-Host "🐘 通过 Docker Compose 启动 Postgres（如果尚未运行）" -ForegroundColor Yellow
      try {
        Push-Location $PSScriptRoot
        docker compose up -d db | Out-Host
      } catch {
        Write-Warning "[db] docker compose failed: $($_.Exception.Message)"
      } finally {
        Pop-Location
      }
    } else {
      Write-Host "[db] Docker not found; skipping DB startup" -ForegroundColor DarkYellow
    }
  }
}

function Ensure-BackendVenvAndDeps {
  $backendDir = Join-Path $PSScriptRoot 'backend'
  $venvPath = Join-Path $backendDir '.venv'
  Push-Location $backendDir
  try {
    if (-not (Test-Path $venvPath)) {
      Write-Host "[后端] 正在创建虚拟环境 .venv" -ForegroundColor Yellow
      python -m venv .venv
    }
    $pipExe = Join-Path $venvPath 'Scripts/pip.exe'
    $pythonExe = Join-Path $venvPath 'Scripts/python.exe'
    if (-not (Test-Path $pythonExe)) { throw "Python venv not created correctly at $venvPath" }
    if (Test-Path (Join-Path $backendDir 'requirements.txt')) {
      Write-Host "[后端] 安装 Python 依赖" -ForegroundColor Yellow
      & $pythonExe -m pip install --upgrade pip | Out-Host
      & $pipExe install -r (Join-Path $backendDir 'requirements.txt') | Out-Host
    }
    return $pythonExe
  } finally {
    Pop-Location
  }
}

function Update-FrontendApiConfig {
  param([int]$Frontend,[int]$Backend)
  $configPath = Join-Path (Join-Path $PSScriptRoot 'frontend') 'src/config/api.ts'
  $configDir = Split-Path $configPath -Parent
  if (-not (Test-Path $configDir)) { New-Item -ItemType Directory -Path $configDir -Force | Out-Null }
  $content = @(
    "// Auto-generated API configuration",
    "export const API_BASE_URL = process.env.NODE_ENV === 'production' ",
    "  ? process.env.NEXT_PUBLIC_API_URL || 'http://localhost:$Backend'",
    "  : 'http://localhost:$Backend';",
    "",
    "export const FRONTEND_URL = 'http://localhost:$Frontend';",
    ""
  ) -join "`n"
  Set-Content -Path $configPath -Value $content -Encoding UTF8
  Write-Host "[前端] 已更新 API 配置：后端=$Backend，前端=$Frontend" -ForegroundColor DarkCyan
}

function Ensure-FrontendDeps {
  $frontendDir = Join-Path $PSScriptRoot 'frontend'
  Push-Location $frontendDir
  try {
    if (-not (Test-Path (Join-Path $frontendDir 'node_modules'))) {
      Write-Host "[前端] 安装 Node 依赖（npm install）" -ForegroundColor Yellow
      & npm install | Out-Host
    }
  } finally {
    Pop-Location
  }
}

function Start-Backend {
  param([int]$Port)
  $backendDir = Join-Path $PSScriptRoot 'backend'
  if (Test-PortInUse -PortToTest $Port) {
    Write-Host "📡 Backend already running — reusing http://localhost:$Port" -ForegroundColor Cyan
    Write-PortFile -Name 'backend' -Port $Port | Out-Null
    return $null
  }
  $pythonExe = Ensure-BackendVenvAndDeps
  Maybe-Start-DB
  Write-Host "📡 Starting Backend on port $Port" -ForegroundColor Yellow
  $job = Start-Job -ScriptBlock {
    param($root, $py, $port)
    Set-Location (Join-Path $root 'backend')
    & $py -m uvicorn app.main:app --reload --host 0.0.0.0 --port $port
  } -ArgumentList $PSScriptRoot, $pythonExe, $Port
  return $job
}

function Start-Frontend {
  param([int]$Port,[int]$BackendPort)
  $frontendDir = Join-Path $PSScriptRoot 'frontend'
  if (Test-PortInUse -PortToTest $Port) {
    Write-Host "🌐 Frontend already running — reusing http://localhost:$Port" -ForegroundColor Cyan
    Update-FrontendApiConfig -Frontend $Port -Backend $BackendPort
    Write-PortFile -Name 'frontend' -Port $Port | Out-Null
    return $null
  }
  Ensure-FrontendDeps
  Update-FrontendApiConfig -Frontend $Port -Backend $BackendPort
  Write-Host "🌐 Starting Frontend on port $Port" -ForegroundColor Yellow
  $job = Start-Job -ScriptBlock {
    param($root, $port)
    Set-Location (Join-Path $root 'frontend')
    $env:NODE_OPTIONS = "--max_old_space_size=4096"
    $env:FRONTEND_PORT = $port
    # Launch Node directly to avoid npm wrapper exiting the job early
    & node start-server.js | Out-Host
  } -ArgumentList $PSScriptRoot, $Port
  return $job
}

# Start services (reuse if already running)
$backendJob = Start-Backend -Port $BackendPort
if ($backendJob) {
  if (-not (Wait-ForPortUp -Port $BackendPort -TimeoutSec 45)) {
    Write-Warning "[后端] 未在超时时间内开放端口 $BackendPort，请检查 Job 输出。"
  }
}
Write-PortFile -Name 'backend' -Port $BackendPort | Out-Null

$frontendJob = Start-Frontend -Port $FrontendPort -BackendPort $BackendPort
if ($frontendJob) {
  if (-not (Wait-ForPortUp -Port $FrontendPort -TimeoutSec 60)) {
    Write-Warning "[前端] 未在超时时间内开放端口 $FrontendPort，以下为前端启动输出："
    try { Receive-Job -Id $frontendJob.Id -Keep | Out-Host } catch { }
  }
}
Write-PortFile -Name 'frontend' -Port $FrontendPort | Out-Null

Write-Host ""
Write-Host ("=" * 80) -ForegroundColor Green
Write-Host "🎉 开发服务已就绪！" -ForegroundColor Green
Write-Host ("=" * 80) -ForegroundColor Green
Write-Host "🌐 前端：  http://localhost:$FrontendPort" -ForegroundColor Cyan
Write-Host "📡 后端：  http://localhost:$BackendPort" -ForegroundColor Magenta
Write-Host "   📖 文档： http://localhost:$BackendPort/docs" -ForegroundColor Magenta
Write-Host ""; Write-Host "🔧 关闭：在此窗口按 Ctrl+C；如为复用模式，请到原窗口停止服务。" -ForegroundColor Yellow
Write-Host ("=" * 80) -ForegroundColor Green

try {
  while ($true) {
    if ($backendJob -and (Get-Job -Id $backendJob.Id -ErrorAction SilentlyContinue)) {
      $bState = (Get-Job -Id $backendJob.Id).State
      if ($bState -ne 'Running') { Write-Warning "[后端] Job 状态：$bState"; break }
    }
    if ($frontendJob -and (Get-Job -Id $frontendJob.Id -ErrorAction SilentlyContinue)) {
      $fState = (Get-Job -Id $frontendJob.Id).State
      if ($fState -ne 'Running') { Write-Warning "[前端] Job 状态：$fState"; break }
    }
    Start-Sleep -Seconds 5
  }
} catch {
  Write-Host "`n🛑 正在停止开发服务..." -ForegroundColor Yellow
} finally {
  if ($backendJob) { Stop-Job -Id $backendJob.Id -PassThru | Remove-Job | Out-Null }
  if ($frontendJob) { Stop-Job -Id $frontendJob.Id -PassThru | Remove-Job | Out-Null }
  Write-Host "👋 开发环境已停止。" -ForegroundColor Gray
}



